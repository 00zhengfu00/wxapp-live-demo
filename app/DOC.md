# 小程序端代码说明

整个小程序端分为4个部分
- `app.js` 负责处理和微信相关的逻辑，用户登录，群组记录，用户状态查询
- `pages/list` 列表页，展示当前正在直播的用户
- `pages/publish` 推流页，主播在该页下推流。提供一些基本的推流选项
- `pages/play` 播放页, 观众观看直播的页面

## App.js
这一部分比较复杂，功能是处理微信的数据并存到自己的数据表中。涉及到不少后端部分的代码，请对照后端部分[代码](https://github.com/pili-engineering/wxapp-live-demo/blob/master/server/routers/wechat.js)

### 存储用户信息
代码里大多都是请求各种微信和自己后台的接口，整个登录工作流程如下:
- 用户打开，调用`wx.login`来获取`code`,
  `code`是包含了用户session数据的一个token，但是出于安全考虑，获取`session`需要后台手动请求微信接口
- 服务端(该项目server下的代码)后台收到code后请求微信获取session存储在后台，用于以后和微信通信。微信返回session的同时，还会带上该用户的`OpenID`, `OpenId`是对一个小程序来说用户的唯一ID。
- 通过上一步拿到的唯一用户ID `OpenId`，我们可以把它作为主键，建立自己的用户表了。微信不会开放除了当前访问者以外的用户信息给我们，所以为了实现`列表页`，我们需要自己维护一个用户表。这一块的逻辑具体见后端代码。
- `wx.login`获取`code`成功后，我们就可以调用`wx.getUserInfo`来获取当前用户的具体信息了（昵称，头像等等）
- 拿到用户的具体信息后，就把这个信息同步给我们的服务端，用之前的`OpenId`作为标示，让后端我们自己的用户表也储存这些数据。

通过上述步骤, 我们就可以让每一个访问过该小程序的人的详细信息都存入我们的用户表里了。这样就方便我们实现后面列表页的功能(因为需要列出用户列表)
*在调用wx.login之前，可以先调用wx.checkSession来判断当前用户的session有没有过期，减少后端获取session的过程*

其实上面的过程中，我们并没有正在用到微信的`session`数据，但是因为`session`和`openid`是一并返回的，就放在一起说了   
下面这个流程，就需要`session`来实现  

### 存储群组信息
微信的各种应用总是要考虑群组的情况，直播这种社交类应用就不用多说。群内直播、群员动态这种功能就需要我们后台除了储存用户表，
还需要存储一个群组表(如无需要可以跳过此段)   
当然，微信是不会给我们直接提供获取当前群成员这种接口的，所以存储群组表的方法就是：   
当一用户从某个群打开小程序的分享卡片时，我们就把这个用户加入这个群组表中。同样的道理，当用户分享小程序到某个群的时候，我们就也可以做这件事。    
这里主要讨论第一种情况，下面说下详细的流程：
- 用户打开成功调用`wx.login`之后，判断用户是否携带了`shareTicket`这个参数，[见此](https://github.com/pili-engineering/wxapp-live-demo/blob/master/app/app.js#L31-L45)
- 如果携带这个参数，表示用户是从某个群组的分享卡片中进入的小程序，我们调用`wx.getShareInfo`传入这个参数就可以获取用户的分享信息了
- 获取分享信息成功后，微信不会直接返回明文数据给我们(安全考虑，防止网络中间人获取敏感信息), 我们得到了`encryptedData`, 和`iv` 2个数据，将这2个参数发给我们服务端端进行解密
- 这里就需要用上刚刚的`session`数据了，`session`为密钥，`iv`为cbc初始向量，`encryptData`为输入调用AES-CBC就可以解密数据了，[见此](https://github.com/pili-engineering/wxapp-live-demo/blob/master/server/utils/wechat.js#L38-L41)
- 后台拿到了分享的解密数据后，就能获取`groupID`，该id是对于一个小程序来说的群组唯一ID，通过这个id我们建立群组表，将当前请求的用户加入用户表

至此我们存储了所有访问用户的详细和相关的群组信息，可以进入我们下面的开发流程了
